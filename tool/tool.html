<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸­è—¥è³‡æ–™åº« - é›²ç«¯ç‰ˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, set, get, push, onValue, remove } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBtUcrBYiE4B1O4xkvIqwxM52Hrh-i6pL8",
            authDomain: "cheungec-ea477.firebaseapp.com",
            databaseURL: "https://cheungec-ea477-default-rtdb.firebaseio.com/",
            projectId: "cheungec-ea477",
            storageBucket: "cheungec-ea477.firebasestorage.app",
            messagingSenderId: "986510230799",
            appId: "1:986510230799:web:f603e67b605e71294f2a7a"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);
        
        // Make Firebase functions globally available
        window.firebaseDB = {
            ref: ref,
            set: set,
            get: get,
            push: push,
            onValue: onValue,
            remove: remove,
            database: database
        };
    </script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300;400;500;600;700&display=swap');
        body {
            font-family: 'Noto Sans TC', sans-serif;
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f4f6;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    
    <header class="bg-white shadow-sm border-b">
        <div class="max-w-6xl mx-auto px-6 py-4">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-3">
                    <div class="w-10 h-10 bg-blue-600 rounded-lg flex items-center justify-center">
                        <span class="text-white font-bold">ä¸­</span>
                    </div>
                    <div>
                        <h1 class="text-xl font-bold text-gray-900">ä¸­è—¥è³‡æ–™åº«</h1>
                        <p class="text-sm text-gray-600">é›²ç«¯ç‰ˆ</p>
                    </div>
                </div>
                <div class="flex items-center space-x-4">
                    <div id="connectionStatus" class="flex items-center space-x-2">
                        <div class="w-2 h-2 bg-yellow-400 rounded-full animate-pulse"></div>
                        <span class="text-sm text-gray-600">é€£ç·šä¸­</span>
                    </div>
                    <div class="text-sm text-gray-500">v2.0</div>
                </div>
            </div>
        </div>
    </header>

    <div class="max-w-6xl mx-auto px-6 py-8">
        
        <div id="loadingIndicator" class="fixed inset-0 bg-white bg-opacity-90 flex items-center justify-center z-50">
            <div class="text-center">
                <div class="loading-spinner mx-auto mb-4"></div>
                <p class="text-gray-600">æ­£åœ¨è¼‰å…¥è³‡æ–™...</p>
            </div>
        </div>

        
        <div id="mainContent" class="grid grid-cols-1 lg:grid-cols-3 gap-8 hidden">
            
            
            <div class="lg:col-span-2 space-y-6">
                
                <div class="bg-white rounded-lg shadow-sm border p-6">
                    <h2 class="text-lg font-semibold text-gray-900 mb-4 flex items-center">
                        <svg class="w-5 h-5 mr-2 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                        </svg>
                        æœå°‹åŠŸèƒ½
                    </h2>
                    
                    <div class="mb-4">
                        <input 
                            type="text" 
                            id="searchInput" 
                            placeholder="è¼¸å…¥ä¸­è—¥åç¨±æˆ–ç—‡ç‹€..."
                            class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none"
                        >
                    </div>

                    <div class="flex space-x-3">
                        <button id="searchBtn" class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-2 rounded-lg font-medium transition-colors">
                            ğŸ” æœå°‹
                        </button>
                        <button id="clearBtn" class="bg-gray-500 hover:bg-gray-600 text-white px-6 py-2 rounded-lg font-medium transition-colors">
                            æ¸…é™¤
                        </button>
                    </div>
                </div>


            </div>

            
            <div class="space-y-6">
                
                <div class="bg-white rounded-lg shadow-sm border p-6">
                    <h2 class="text-lg font-semibold text-gray-900 mb-4 flex items-center">
                        <svg class="w-5 h-5 mr-2 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                        </svg>
                        è³‡æ–™å°å…¥
                    </h2>
                    
                    
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-700 mb-2">
                            æ™ºèƒ½æ ¼å¼è­˜åˆ¥
                        </label>
                        <div class="flex items-center justify-between mb-2">
                            <div id="formatHint" class="text-xs text-blue-600"></div>
                        </div>
                        <textarea 
                            id="importData" 
                            placeholder="æ”¯æ´å¤šç¨®æ ¼å¼ï¼Œä¾‹å¦‚ï¼š&#10;å†’è™Ÿæ ¼å¼ï¼šç•¶æ­¸ï¼šè£œè¡€èª¿ç¶“ï¼Œæ´»è¡€æ­¢ç—›&#10;é€—è™Ÿæ ¼å¼ï¼šé»ƒèŠª,è£œæ°£å›ºè¡¨ã€åˆ©å°¿æ‰˜æ¯’&#10;ç®­é ­æ ¼å¼ï¼šäººåƒâ†’å¤§è£œå…ƒæ°£ï¼Œå¾©è„ˆå›ºè„«&#10;æ¨™é»ç¬¦è™Ÿï¼šç™½èŠï¼šé¤Šè¡€æŸ”è‚ã€‚ç·©ä¸­æ­¢ç—›ï¼æ–‚é™°æ”¶æ±—ï¼Ÿ&#10;æ··åˆåˆ†éš”ï¼šä¸¹åƒï¼šæ´»è¡€åŒ–ç˜€ï¼Œæ¶¼è¡€æ¶ˆç™°ï¼›é™¤ç…©å®‰ç¥"
                            class="w-full h-32 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none resize-none text-sm"
                        ></textarea>
                    </div>
                    
                    
                    <div class="space-y-3">
                        <button id="importBtn" class="w-full bg-green-600 hover:bg-green-700 text-white py-2 rounded-lg font-medium transition-colors">
                            â¬†ï¸ æ™ºèƒ½å°å…¥åˆ°é›²ç«¯
                        </button>
                        
                        
                        <div id="progressContainer" class="hidden bg-gray-50 rounded-lg p-4">
                            <div class="flex items-center justify-between mb-2">
                                <span id="progressText" class="text-sm text-gray-600">æº–å‚™å°å…¥...</span>
                                <span id="progressPercent" class="text-sm font-medium text-blue-600">0%</span>
                            </div>
                            <div class="w-full bg-gray-200 rounded-full h-2">
                                <div id="progressBar" class="bg-blue-600 h-2 rounded-full transition-all duration-300 ease-out" style="width: 0%"></div>
                            </div>
                        </div>
                        
                        <button id="clearAllBtn" class="w-full bg-gray-500 hover:bg-gray-600 text-white py-2 rounded-lg font-medium transition-colors">
                            ğŸ—‘ï¸ æ¸…ç©ºè¼¸å…¥
                        </button>
                        
                        <div class="grid grid-cols-2 gap-2">
                            <button id="editModeBtn" class="bg-purple-600 hover:bg-purple-700 text-white py-2 rounded-lg font-medium transition-colors text-sm">
                                âœï¸ ç·¨è¼¯æ¨¡å¼
                            </button>
                            <button id="clearDatabaseBtn" class="bg-red-600 hover:bg-red-700 text-white py-2 rounded-lg font-medium transition-colors text-sm">
                                ğŸ’¥ æ¸…ç©ºè³‡æ–™åº«
                            </button>
                        </div>
                        
                        <button id="exportDataBtn" class="w-full bg-orange-600 hover:bg-orange-700 text-white py-2 rounded-lg font-medium transition-colors">
                            ğŸ“¤ å°å‡ºè³‡æ–™ (TXT)
                        </button>
                        </div>
                    </div>
                    

                </div>

                
                <div class="bg-white rounded-lg shadow-sm border p-6">
                    <h3 class="text-lg font-semibold text-gray-900 mb-4 flex items-center">
                        <svg class="w-5 h-5 mr-2 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                        </svg>
                        çµ±è¨ˆè³‡è¨Š
                    </h3>
                    <div class="space-y-3">
                        <div class="flex justify-between items-center">
                            <span class="text-gray-600">ä¸­è—¥æ•¸é‡</span>
                            <span id="herbCount" class="font-semibold text-blue-600">è¼‰å…¥ä¸­...</span>
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-gray-600">ç—‡ç‹€æ•¸é‡</span>
                            <span id="symptomCount" class="font-semibold text-green-600">è¼‰å…¥ä¸­...</span>
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-gray-600">ç¸½è¨˜éŒ„æ•¸</span>
                            <span id="recordCount" class="font-semibold text-purple-600">è¼‰å…¥ä¸­...</span>
                        </div>
                    </div>
                </div>


            </div>
        </div>

        
        <div id="dataDisplay" class="mt-8 grid grid-cols-1 lg:grid-cols-2 gap-8 hidden">
            
            <div class="bg-white rounded-lg shadow-sm border p-6">
                <h3 class="text-lg font-semibold text-gray-900 mb-4 flex items-center">
                    <div class="w-3 h-3 bg-blue-500 rounded-full mr-2"></div>
                    ä¸­è—¥åˆ—è¡¨
                </h3>
                <div id="herbsList" class="max-h-64 overflow-y-auto space-y-2">
                    <p class="text-gray-500 text-center py-8">è¼‰å…¥ä¸­...</p>
                </div>
            </div>

            
            <div class="bg-white rounded-lg shadow-sm border p-6">
                <h3 class="text-lg font-semibold text-gray-900 mb-4 flex items-center">
                    <div class="w-3 h-3 bg-green-500 rounded-full mr-2"></div>
                    ç—‡ç‹€åˆ—è¡¨
                </h3>
                <div id="symptomsList" class="max-h-64 overflow-y-auto space-y-2">
                    <p class="text-gray-500 text-center py-8">è¼‰å…¥ä¸­...</p>
                </div>
            </div>
        </div>
    </div>

    
    <div id="searchModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-lg shadow-xl max-w-4xl w-full mx-4 max-h-[90vh] overflow-hidden">
            
            <div class="flex items-center justify-between p-6 border-b border-gray-200">
                <div class="flex items-center space-x-3">
                    <div class="w-8 h-8 bg-blue-600 rounded-lg flex items-center justify-center">
                        <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                        </svg>
                    </div>
                    <div>
                        <h3 class="text-lg font-semibold text-gray-900">æœå°‹çµæœ</h3>
                        <p id="modalSearchQuery" class="text-sm text-gray-600"></p>
                    </div>
                </div>
                <button id="closeModal" class="text-gray-400 hover:text-gray-600 transition-colors">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            
            
            <div class="p-6 overflow-y-auto max-h-[calc(90vh-120px)]">
                <div id="modalResultsContainer">
                    
                </div>
            </div>
            
            
            <div class="flex items-center justify-between p-6 border-t border-gray-200 bg-gray-50">
                <div class="flex items-center space-x-4">
                    <span id="modalResultCount" class="text-sm text-gray-600"></span>
                    <div class="flex items-center space-x-2">
                        <div class="w-3 h-3 bg-blue-500 rounded-full"></div>
                        <span class="text-xs text-gray-500">ä¸­è—¥</span>
                        <div class="w-3 h-3 bg-green-500 rounded-full ml-4"></div>
                        <span class="text-xs text-gray-500">ç—‡ç‹€</span>
                    </div>
                </div>
                <button id="newSearchBtn" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                    ğŸ” æ–°æœå°‹
                </button>
            </div>
        </div>
    </div>

    
    <div id="editModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[9999] hidden">
        <div class="bg-white rounded-lg shadow-xl max-w-5xl w-full mx-4 max-h-[90vh] overflow-hidden">
            
            <div class="flex items-center justify-between p-6 border-b border-gray-200">
                <div class="flex items-center space-x-3">
                    <div class="w-8 h-8 bg-purple-600 rounded-lg flex items-center justify-center">
                        <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
                        </svg>
                    </div>
                    <div>
                        <h3 class="text-lg font-semibold text-gray-900">ç·¨è¼¯è³‡æ–™</h3>
                        <p class="text-sm text-gray-600">ä¿®æ”¹ä¸­è—¥å’Œç—‡ç‹€è³‡æ–™</p>
                    </div>
                </div>
                <button id="closeEditModal" class="text-gray-400 hover:text-gray-600 transition-colors">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            
            
            <div class="p-6 overflow-y-auto max-h-[calc(90vh-180px)]">
                
                <div class="mb-6">
                    <div class="flex space-x-4 mb-4">
                        <input 
                            type="text" 
                            id="editSearchInput" 
                            placeholder="æœå°‹è¦ç·¨è¼¯çš„é …ç›®..."
                            class="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-purple-500 outline-none"
                        >
                        <select id="editTypeFilter" class="px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-purple-500 outline-none">
                            <option value="all">å…¨éƒ¨</option>
                            <option value="herb">ä¸­è—¥</option>
                            <option value="symptom">ç—‡ç‹€</option>
                        </select>
                    </div>
                </div>
                
                
                <div id="editItemsList" class="space-y-3">
                    
                </div>
            </div>
            
            
            <div class="flex items-center justify-between p-6 border-t border-gray-200 bg-gray-50">
                <div class="flex items-center space-x-4">
                    <span id="editItemCount" class="text-sm text-gray-600">è¼‰å…¥ä¸­...</span>
                    <div class="flex items-center space-x-2">
                        <div class="w-3 h-3 bg-blue-500 rounded-full"></div>
                        <span class="text-xs text-gray-500">ä¸­è—¥</span>
                        <div class="w-3 h-3 bg-green-500 rounded-full ml-4"></div>
                        <span class="text-xs text-gray-500">ç—‡ç‹€</span>
                    </div>
                </div>
                <button id="closeEditModalBtn" class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                    é—œé–‰
                </button>
            </div>
        </div>
    </div>

    
    <div id="editDetailModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[10000] hidden">
        <div class="bg-white rounded-lg shadow-xl max-w-2xl w-full mx-4 max-h-[80vh] overflow-hidden">
            
            <div class="flex items-center justify-between p-6 border-b border-gray-200">
                <div class="flex items-center space-x-3">
                    <div id="editDetailIcon" class="w-8 h-8 bg-blue-600 rounded-lg flex items-center justify-center">
                        <span class="text-white font-bold">ç·¨</span>
                    </div>
                    <div>
                        <h3 id="editDetailTitle" class="text-lg font-semibold text-gray-900">ç·¨è¼¯é …ç›®</h3>
                        <p id="editDetailSubtitle" class="text-sm text-gray-600">ä¿®æ”¹åç¨±å’Œé—œè¯é …ç›®</p>
                    </div>
                </div>
                <button id="closeEditDetailModal" class="text-gray-400 hover:text-gray-600 transition-colors">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            
            
            <div class="p-6 overflow-y-auto max-h-[calc(80vh-180px)]">
                
                <div class="mb-6">
                    <label class="block text-sm font-medium text-gray-700 mb-2">åç¨±</label>
                    <input 
                        type="text" 
                        id="editItemName" 
                        class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-purple-500 outline-none"
                        placeholder="è¼¸å…¥æ–°åç¨±..."
                    >
                </div>
                
                
                <div class="mb-6">
                    <label id="editRelatedLabel" class="block text-sm font-medium text-gray-700 mb-2">é—œè¯é …ç›®</label>
                    <div class="space-y-2 mb-4">
                        <div id="editRelatedItems" class="space-y-2">
                            
                        </div>
                    </div>
                    
                    
                    <div class="flex space-x-2">
                        <input 
                            type="text" 
                            id="newRelatedItem" 
                            placeholder="æ–°å¢é—œè¯é …ç›®..."
                            class="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-purple-500 outline-none text-sm"
                        >
                        <button id="addRelatedItemBtn" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                            æ–°å¢
                        </button>
                    </div>
                </div>
            </div>
            
            
            <div class="flex items-center justify-between p-6 border-t border-gray-200 bg-gray-50">
                <button id="deleteItemBtn" class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                    ğŸ—‘ï¸ åˆªé™¤é …ç›®
                </button>
                <div class="flex space-x-3">
                    <button id="cancelEditBtn" class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                        å–æ¶ˆ
                    </button>
                    <button id="saveEditBtn" class="bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                        ğŸ’¾ å„²å­˜è®Šæ›´
                    </button>
                </div>
            </div>
        </div>
    </div>

    
    <div id="toast" class="fixed top-4 right-4 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg transform translate-x-full transition-transform duration-300 z-[10001]">
        <div class="flex items-center space-x-2">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
            </svg>
            <span id="toastMessage">æ“ä½œæˆåŠŸ</span>
        </div>
    </div>

    <script>
        // Global variables
        let herbsData = {};
        let symptomsData = {};
        let recordsData = {};
        let isFirebaseReady = false;

        // DOM elements
        const searchInput = document.getElementById('searchInput');
        const searchBtn = document.getElementById('searchBtn');
        const clearBtn = document.getElementById('clearBtn');
        const importData = document.getElementById('importData');
        const importBtn = document.getElementById('importBtn');
        const clearAllBtn = document.getElementById('clearAllBtn');
        const clearDatabaseBtn = document.getElementById('clearDatabaseBtn');
        const editModeBtn = document.getElementById('editModeBtn');
        const exportDataBtn = document.getElementById('exportDataBtn');
        const herbCount = document.getElementById('herbCount');
        const symptomCount = document.getElementById('symptomCount');
        const recordCount = document.getElementById('recordCount');
        const herbsList = document.getElementById('herbsList');
        const symptomsList = document.getElementById('symptomsList');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const mainContent = document.getElementById('mainContent');
        const dataDisplay = document.getElementById('dataDisplay');
        const connectionStatus = document.getElementById('connectionStatus');
        const toast = document.getElementById('toast');
        const toastMessage = document.getElementById('toastMessage');
        
        // Modal elements
        const searchModal = document.getElementById('searchModal');
        const modalResultsContainer = document.getElementById('modalResultsContainer');
        const modalSearchQuery = document.getElementById('modalSearchQuery');
        const modalResultCount = document.getElementById('modalResultCount');
        const closeModal = document.getElementById('closeModal');
        const newSearchBtn = document.getElementById('newSearchBtn');
        
        // Smart import elements
        const formatHint = document.getElementById('formatHint');
        
        // Progress bar elements
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const progressPercent = document.getElementById('progressPercent');
        
        // Edit modal elements
        const editModal = document.getElementById('editModal');
        const editSearchInput = document.getElementById('editSearchInput');
        const editTypeFilter = document.getElementById('editTypeFilter');
        const editItemsList = document.getElementById('editItemsList');
        const editItemCount = document.getElementById('editItemCount');
        const closeEditModal = document.getElementById('closeEditModal');
        const closeEditModalBtn = document.getElementById('closeEditModalBtn');
        
        // Edit detail modal elements
        const editDetailModal = document.getElementById('editDetailModal');
        const editDetailIcon = document.getElementById('editDetailIcon');
        const editDetailTitle = document.getElementById('editDetailTitle');
        const editDetailSubtitle = document.getElementById('editDetailSubtitle');
        const editItemName = document.getElementById('editItemName');
        const editRelatedLabel = document.getElementById('editRelatedLabel');
        const editRelatedItems = document.getElementById('editRelatedItems');
        const newRelatedItem = document.getElementById('newRelatedItem');
        const addRelatedItemBtn = document.getElementById('addRelatedItemBtn');
        const deleteItemBtn = document.getElementById('deleteItemBtn');
        const cancelEditBtn = document.getElementById('cancelEditBtn');
        const saveEditBtn = document.getElementById('saveEditBtn');
        const closeEditDetailModal = document.getElementById('closeEditDetailModal');
        
        // Edit state variables
        let currentEditItem = null;
        let currentEditType = null;
        let editItemsData = [];

        // Wait for Firebase to be ready
        function waitForFirebase() {
            return new Promise((resolve) => {
                const checkFirebase = () => {
                    if (window.firebaseDB) {
                        resolve();
                    } else {
                        setTimeout(checkFirebase, 100);
                    }
                };
                checkFirebase();
            });
        }

        // Show toast notification
        function showToast(message, type = 'success') {
            toastMessage.innerHTML = message.replace(/\n/g, '<br>'); // æ”¯æ´æ›è¡Œé¡¯ç¤º
            toast.className = `fixed top-4 right-4 px-6 py-3 rounded-lg shadow-lg transform transition-transform duration-300 z-50 ${
                type === 'success' ? 'bg-green-500' : type === 'error' ? 'bg-red-500' : type === 'info' ? 'bg-blue-500' : 'bg-blue-500'
            } text-white max-w-sm`;
            toast.style.transform = 'translateX(0)';
            
            // æ ¹æ“šè¨Šæ¯é•·åº¦èª¿æ•´é¡¯ç¤ºæ™‚é–“
            const displayTime = message.length > 50 ? 5000 : 3000;
            
            setTimeout(() => {
                toast.style.transform = 'translateX(100%)';
            }, displayTime);
        }

        // Initialize Firebase listeners
        async function initializeFirebase() {
            try {
                await waitForFirebase();
                
                // Listen to records data
                const recordsRef = window.firebaseDB.ref(window.firebaseDB.database, 'tcm-records');
                window.firebaseDB.onValue(recordsRef, (snapshot) => {
                    const data = snapshot.val();
                    recordsData = data || {};
                    processRecordsData();
                    updateDisplay();
                    
                    if (!isFirebaseReady) {
                        isFirebaseReady = true;
                        loadingIndicator.classList.add('hidden');
                        mainContent.classList.remove('hidden');
                        dataDisplay.classList.remove('hidden');
                        showToast('è³‡æ–™è¼‰å…¥å®Œæˆ', 'success');
                    }
                });

                // Start connection monitoring
                monitorConnection();
            } catch (error) {
                console.error('Firebase initialization error:', error);
                updateConnectionStatus(false);
                showToast('é€£ç·šå¤±æ•—ï¼Œä½¿ç”¨é›¢ç·šæ¨¡å¼', 'error');
                
                // Show content anyway for demo
                loadingIndicator.classList.add('hidden');
                mainContent.classList.remove('hidden');
                dataDisplay.classList.remove('hidden');
            }
        }

        // Update connection status
        function updateConnectionStatus(connected) {
            const statusDot = connectionStatus.querySelector('div');
            const statusText = connectionStatus.querySelector('span');
            
            if (connected) {
                statusDot.className = 'w-2 h-2 bg-green-400 rounded-full';
                statusText.textContent = 'å·²é€£ç·š';
            } else {
                statusDot.className = 'w-2 h-2 bg-red-400 rounded-full animate-pulse';
                statusText.textContent = 'é›¢ç·š';
            }
        }

        // Real-time connection monitoring
        function monitorConnection() {
            const connectedRef = window.firebaseDB.ref(window.firebaseDB.database, '.info/connected');
            window.firebaseDB.onValue(connectedRef, (snapshot) => {
                const connected = snapshot.val();
                updateConnectionStatus(connected);
                
                if (connected) {
                    console.log('Firebase connected');
                } else {
                    console.log('Firebase disconnected');
                }
            });
        }

        // Progress bar functions
        function showProgress() {
            progressContainer.classList.remove('hidden');
            importBtn.disabled = true;
            importBtn.classList.add('opacity-50', 'cursor-not-allowed');
        }

        function hideProgress() {
            progressContainer.classList.add('hidden');
            importBtn.disabled = false;
            importBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            updateProgress(0, 'æº–å‚™å°å…¥...');
        }

        function updateProgress(percent, text) {
            progressBar.style.width = percent + '%';
            progressPercent.textContent = Math.round(percent) + '%';
            progressText.textContent = text;
        }

        // Process records data into herbs and symptoms
        function processRecordsData() {
            herbsData = {};
            symptomsData = {};

            // ç¢ºä¿ recordsData å­˜åœ¨ä¸”ç‚ºç‰©ä»¶
            if (!recordsData || typeof recordsData !== 'object') {
                console.warn('recordsData is not valid:', recordsData);
                return;
            }

            Object.values(recordsData).forEach(record => {
                // é©—è­‰è¨˜éŒ„æ ¼å¼
                if (!record || typeof record !== 'object') {
                    return;
                }

                const herb = record.herb;
                const symptom = record.symptom;

                // ç¢ºä¿ä¸­è—¥åç¨±å’Œç—‡ç‹€éƒ½å­˜åœ¨ä¸”ç‚ºå­—ä¸²
                if (!herb || !symptom || typeof herb !== 'string' || typeof symptom !== 'string') {
                    return;
                }

                // æ¸…ç†å­—ä¸²ï¼Œç§»é™¤å¤šé¤˜ç©ºç™½
                const cleanHerb = herb.trim();
                const cleanSymptom = symptom.trim();

                if (!cleanHerb || !cleanSymptom) {
                    return;
                }

                // Add to herbs data
                if (!herbsData[cleanHerb]) {
                    herbsData[cleanHerb] = [];
                }
                if (!herbsData[cleanHerb].includes(cleanSymptom)) {
                    herbsData[cleanHerb].push(cleanSymptom);
                }

                // Add to symptoms data
                if (!symptomsData[cleanSymptom]) {
                    symptomsData[cleanSymptom] = [];
                }
                if (!symptomsData[cleanSymptom].includes(cleanHerb)) {
                    symptomsData[cleanSymptom].push(cleanHerb);
                }
            });

            // èª¿è©¦è¼¸å‡º
            console.log('è™•ç†å®Œæˆ - ä¸­è—¥æ•¸é‡:', Object.keys(herbsData).length);
            console.log('è™•ç†å®Œæˆ - ç—‡ç‹€æ•¸é‡:', Object.keys(symptomsData).length);
            console.log('ç—‡ç‹€è³‡æ–™ç¯„ä¾‹:', Object.keys(symptomsData).slice(0, 5));
        }

        // Smart data parsing functions
        function detectFormat(text) {
            const lines = text.split('\n').filter(line => line.trim());
            if (lines.length === 0) return 'unknown';
            
            const formats = {
                colon: 0,
                comma: 0,
                arrow: 0,
                bracket: 0,
                json: 0
            };
            
            lines.forEach(line => {
                if (line.includes('ï¼š') || line.includes(':')) formats.colon++;
                if (line.includes(',')) formats.comma++;
                if (line.includes('â†’') || line.includes('->')) formats.arrow++;
                if (line.includes('[') && line.includes(']')) formats.bracket++;
                if (line.trim().startsWith('{') || line.trim().startsWith('[')) formats.json++;
            });
            
            return Object.keys(formats).reduce((a, b) => formats[a] > formats[b] ? a : b);
        }

        function parseDataByFormat(text, format) {
            const lines = text.split('\n').filter(line => line.trim());
            const results = [];
            
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (!trimmedLine) return;
                
                let herb = '', symptomsText = '';
                
                try {
                    // Try different formats in order
                    if (trimmedLine.includes('ï¼š')) {
                        [herb, symptomsText] = trimmedLine.split('ï¼š');
                    } else if (trimmedLine.includes(':')) {
                        [herb, symptomsText] = trimmedLine.split(':');
                    } else if (trimmedLine.includes(',')) {
                        [herb, symptomsText] = trimmedLine.split(',');
                    } else if (trimmedLine.includes('â†’')) {
                        [herb, symptomsText] = trimmedLine.split('â†’');
                    } else if (trimmedLine.includes('->')) {
                        [herb, symptomsText] = trimmedLine.split('->');
                    } else if (trimmedLine.includes('[') && trimmedLine.includes(']')) {
                        const bracketMatch = trimmedLine.match(/^(.+?)\[(.+?)\]$/);
                        if (bracketMatch) {
                            herb = bracketMatch[1];
                            symptomsText = bracketMatch[2];
                        }
                    } else if (trimmedLine.startsWith('{')) {
                        try {
                            const jsonData = JSON.parse(trimmedLine);
                            if (jsonData.herb && jsonData.symptom) {
                                herb = jsonData.herb;
                                symptomsText = jsonData.symptom;
                            } else if (jsonData.name && jsonData.effect) {
                                herb = jsonData.name;
                                symptomsText = jsonData.effect;
                            }
                        } catch (e) {
                            // Invalid JSON, skip
                        }
                    }
                    
                    if (herb && symptomsText) {
                        // åªç§»é™¤ç‰¹æ®Šç¬¦è™Ÿï¼Œä¿ç•™æ‰€æœ‰æ‹¬è™Ÿ
                        herb = herb.trim().replace(/[^\u4e00-\u9fa5a-zA-Z0-9ã€ï¼ˆï¼‰()ã€ã€‘ã€”ã€•ã€Œã€ã€ã€ã€Šã€‹ã€ˆã€‰]/g, '');
                        symptomsText = symptomsText.trim();
                        
                        // Split multiple symptoms by separators but preserve brackets in content
                        const symptoms = symptomsText.split(/[ï¼Œ,ã€ï¼›;|\/\\ã€‚ï¼ï¼Ÿâ€¦ï¼š]/)
                            .map(s => s.trim().replace(/^[ï¼Œã€‚ã€ï¼›ï¼šï¼ï¼Ÿâ€¦\s\/\\|]+|[ï¼Œã€‚ã€ï¼›ï¼šï¼ï¼Ÿâ€¦\s\/\\|]+$/g, ''))
                            .filter(s => s.length > 0 && s !== 'ã€€'); // Filter out empty strings and full-width spaces
                        
                        // Create a result for each symptom
                        symptoms.forEach(symptom => {
                            if (herb && symptom) {
                                results.push({ herb, symptom, original: trimmedLine });
                            }
                        });
                    }
                } catch (error) {
                    console.warn('Parse error for line:', trimmedLine, error);
                }
            });
            
            return results;
        }

        // Import data to Firebase with robust error handling
        async function importDataFunction() {
            const data = importData.value.trim();
            if (!data) {
                showToast('è«‹è¼¸å…¥è¦å°å…¥çš„è³‡æ–™', 'error');
                return;
            }

            // Parse data with auto-detection
            const detectedFormat = detectFormat(data);
            const parsedData = parseDataByFormat(data, detectedFormat);
            
            if (parsedData.length === 0) {
                showToast('æ²’æœ‰æœ‰æ•ˆçš„è³‡æ–™å¯ä»¥å°å…¥', 'error');
                return;
            }

            // Remove duplicates and prepare data
            const seen = new Set();
            const validData = [];
            let skipCount = 0;

            // Show progress bar
            showProgress();
            updateProgress(5, 'ğŸ“‹ è³‡æ–™é è™•ç†ä¸­...');

            // Pre-process all data
            parsedData.forEach(item => {
                const key = `${item.herb}_${item.symptom}`;
                if (seen.has(key)) return;
                seen.add(key);

                const recordKey = `${item.herb}_${item.symptom}`.replace(/[.#$[\]]/g, '_');
                
                // Check for duplicates in existing data
                if (recordsData[recordKey]) {
                    skipCount++;
                    return;
                }

                validData.push({
                    key: recordKey,
                    herb: item.herb,
                    symptom: item.symptom,
                    timestamp: Date.now()
                });
            });

            const totalItems = validData.length;
            
            if (totalItems === 0) {
                updateProgress(100, 'æ²’æœ‰æ–°è³‡æ–™éœ€è¦å°å…¥');
                await new Promise(resolve => setTimeout(resolve, 600));
                hideProgress();
                showToast(`æ‰€æœ‰ ${skipCount} ç­†è³‡æ–™å·²å­˜åœ¨ï¼Œç„¡éœ€é‡è¤‡å°å…¥`, 'info');
                return;
            }

            try {
                updateProgress(15, `ğŸ“¤ æº–å‚™å°å…¥ ${totalItems} ç­†è³‡æ–™...`);

                // Always use safe individual writes for maximum reliability
                let completed = 0;
                let failed = 0;
                const batchSize = 10; // Conservative batch size
                
                // Process in small batches to avoid overwhelming Firebase
                for (let i = 0; i < validData.length; i += batchSize) {
                    const batch = validData.slice(i, i + batchSize);
                    
                    updateProgress(
                        15 + (i / validData.length) * 70, 
                        `ğŸ“ è™•ç†ç¬¬ ${Math.floor(i/batchSize) + 1} æ‰¹ (${i + 1}-${Math.min(i + batchSize, validData.length)})`
                    );

                    // Process batch items with individual error handling
                    const batchPromises = batch.map(async (item) => {
                        try {
                            // Check if Firebase is available
                            if (!window.firebaseDB || !window.firebaseDB.database) {
                                throw new Error('Firebase æœªåˆå§‹åŒ–');
                            }

                            const recordRef = window.firebaseDB.ref(window.firebaseDB.database, `tcm-records/${item.key}`);
                            await window.firebaseDB.set(recordRef, {
                                herb: item.herb,
                                symptom: item.symptom,
                                timestamp: item.timestamp
                            });
                            
                            completed++;
                            return { success: true, item };
                        } catch (error) {
                            console.warn('Single item failed:', item, error);
                            failed++;
                            return { success: false, item, error };
                        }
                    });

                    // Wait for current batch to complete
                    await Promise.all(batchPromises);
                    
                    // Small delay between batches to prevent rate limiting
                    if (i + batchSize < validData.length) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }

                // Final progress
                updateProgress(90, 'âœ… å°å…¥å®Œæˆï¼Œæ­£åœ¨åŒæ­¥...');
                await new Promise(resolve => setTimeout(resolve, 500));
                updateProgress(100, 'ğŸ‰ åŒæ­¥å®Œæˆï¼');

                // Wait briefly before hiding
                await new Promise(resolve => setTimeout(resolve, 800));

                importData.value = '';
                formatHint.textContent = '';
                
                // æ§‹å»ºè©³ç´°çš„å®Œæˆè¨Šæ¯
                let message = '';
                let toastType = 'success';
                
                if (completed > 0) {
                    message = `ğŸ‰ å°å…¥æˆåŠŸï¼æ–°å¢ ${completed} ç­†è³‡æ–™`;
                    
                    // æ·»åŠ è©³ç´°çµ±è¨ˆ
                    const details = [];
                    if (failed > 0) {
                        details.push(`${failed} ç­†å¤±æ•—`);
                        toastType = 'info'; // éƒ¨åˆ†æˆåŠŸç”¨ info é¡è‰²
                    }
                    if (skipCount > 0) {
                        details.push(`${skipCount} ç­†å·²å­˜åœ¨`);
                    }
                    
                    if (details.length > 0) {
                        message += ` (${details.join('ï¼Œ')})`;
                    }
                    
                    // é¡¯ç¤ºè³‡æ–™åº«çµ±è¨ˆ
                    const totalRecords = Object.keys(recordsData).length + completed;
                    message += `\nğŸ“Š è³‡æ–™åº«ç¾æœ‰ ${totalRecords} ç­†è¨˜éŒ„`;
                    
                } else if (skipCount > 0) {
                    message = `â„¹ï¸ æ‰€æœ‰ ${skipCount} ç­†è³‡æ–™å·²å­˜åœ¨ï¼Œç„¡éœ€é‡è¤‡å°å…¥`;
                    toastType = 'info';
                } else {
                    message = `âŒ å°å…¥å¤±æ•—ï¼š${failed} ç­†è³‡æ–™è™•ç†å¤±æ•—`;
                    toastType = 'error';
                }
                
                showToast(message, toastType);
                
            } catch (error) {
                console.error('Import error:', error);
                updateProgress(100, 'âŒ å°å…¥å¤±æ•—');
                
                let errorMessage = 'å°å…¥å¤±æ•—';
                if (error.message) {
                    if (error.message.includes('permission') || error.message.includes('PERMISSION')) {
                        errorMessage = 'æ¬Šé™ä¸è¶³ï¼Œè«‹æª¢æŸ¥ Firebase è¨­å®š';
                    } else if (error.message.includes('network') || error.message.includes('offline')) {
                        errorMessage = 'ç¶²è·¯é€£ç·šå•é¡Œï¼Œè«‹æª¢æŸ¥ç¶²è·¯å¾Œé‡è©¦';
                    } else if (error.message.includes('Firebase')) {
                        errorMessage = 'Firebase é€£ç·šå•é¡Œï¼Œè«‹é‡æ–°æ•´ç†é é¢';
                    } else {
                        errorMessage = `å°å…¥å¤±æ•—: ${error.message}`;
                    }
                }
                
                showToast(errorMessage, 'error');
                
                // Wait before hiding progress
                await new Promise(resolve => setTimeout(resolve, 1000));
            } finally {
                hideProgress();
            }
        }





        // Clear input data
        function clearAllData() {
            if (!confirm('ç¢ºå®šè¦æ¸…ç©ºè¼¸å…¥æ¬„çš„è³‡æ–™å—ï¼Ÿ')) {
                return;
            }

            importData.value = '';
            formatHint.textContent = '';
            showToast('è¼¸å…¥è³‡æ–™å·²æ¸…ç©º', 'success');
        }

        // Export data to TXT file
        function exportDataToTxt() {
            if (!isFirebaseReady) {
                showToast('æ­£åœ¨é€£ç·šä¸­ï¼Œè«‹ç¨å€™...', 'info');
                return;
            }

            if (Object.keys(recordsData).length === 0) {
                showToast('æ²’æœ‰è³‡æ–™å¯ä»¥å°å‡º', 'error');
                return;
            }

            try {
                exportDataBtn.disabled = true;
                exportDataBtn.innerHTML = 'ğŸ“¤ å°å‡ºä¸­...';

                // Prepare export data
                let exportContent = '';
                
                // Add header with timestamp
                const now = new Date();
                const timestamp = now.toLocaleString('zh-TW', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
                
                exportContent += `ä¸­è—¥è³‡æ–™åº«å°å‡ºæª”æ¡ˆ\n`;
                exportContent += `å°å‡ºæ™‚é–“ï¼š${timestamp}\n`;
                exportContent += `ç¸½è¨˜éŒ„æ•¸ï¼š${Object.keys(recordsData).length}\n`;
                exportContent += `ä¸­è—¥æ•¸é‡ï¼š${Object.keys(herbsData).length}\n`;
                exportContent += `ç—‡ç‹€æ•¸é‡ï¼š${Object.keys(symptomsData).length}\n`;
                exportContent += `${'='.repeat(50)}\n\n`;

                // Export by herbs (grouped format)
                exportContent += `ã€æŒ‰ä¸­è—¥åˆ†é¡ã€‘\n`;
                exportContent += `${'='.repeat(30)}\n\n`;
                
                const sortedHerbs = Object.keys(herbsData).sort();
                sortedHerbs.forEach((herb, index) => {
                    const symptoms = herbsData[herb].sort();
                    exportContent += `${index + 1}. ${herb}ï¼š${symptoms.join('ã€')}\n`;
                });

                exportContent += `\n${'='.repeat(50)}\n\n`;

                // Export by symptoms (grouped format)
                exportContent += `ã€æŒ‰ç—‡ç‹€åˆ†é¡ã€‘\n`;
                exportContent += `${'='.repeat(30)}\n\n`;
                
                const sortedSymptoms = Object.keys(symptomsData).sort();
                sortedSymptoms.forEach((symptom, index) => {
                    const herbs = symptomsData[symptom].sort();
                    exportContent += `${index + 1}. ${symptom}ï¼š${herbs.join('ã€')}\n`;
                });

                exportContent += `\n${'='.repeat(50)}\n\n`;

                // Export raw records (for re-import)
                exportContent += `ã€åŸå§‹è¨˜éŒ„æ ¼å¼ã€‘\n`;
                exportContent += `${'='.repeat(30)}\n`;
                exportContent += `ï¼ˆæ­¤æ ¼å¼å¯ç›´æ¥ç”¨æ–¼é‡æ–°å°å…¥ï¼‰\n\n`;
                
                const sortedRecords = Object.values(recordsData).sort((a, b) => {
                    if (a.herb !== b.herb) {
                        return a.herb.localeCompare(b.herb);
                    }
                    return a.symptom.localeCompare(b.symptom);
                });
                
                sortedRecords.forEach(record => {
                    exportContent += `${record.herb}ï¼š${record.symptom}\n`;
                });

                // Create and download file
                const blob = new Blob([exportContent], { type: 'text/plain;charset=utf-8' });
                const url = window.URL.createObjectURL(blob);
                const link = document.createElement('a');
                
                // Generate filename with timestamp
                const filename = `ä¸­è—¥è³‡æ–™åº«_${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}.txt`;
                
                link.href = url;
                link.download = filename;
                link.style.display = 'none';
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Clean up
                window.URL.revokeObjectURL(url);
                
                showToast(`ğŸ“¤ è³‡æ–™å·²å°å‡ºè‡³ ${filename}\nåŒ…å« ${Object.keys(recordsData).length} ç­†è¨˜éŒ„`, 'success');
                
            } catch (error) {
                console.error('Export error:', error);
                showToast('å°å‡ºå¤±æ•—ï¼š' + error.message, 'error');
            } finally {
                exportDataBtn.disabled = false;
                exportDataBtn.innerHTML = 'ğŸ“¤ å°å‡ºè³‡æ–™ (TXT)';
            }
        }

        // Clear entire database
        async function clearDatabase() {
            if (!confirm('âš ï¸ è­¦å‘Šï¼šé€™å°‡æ¸…é™¤æ•´å€‹è³‡æ–™åº«çš„æ‰€æœ‰å…§å®¹ï¼\n\næ­¤æ“ä½œç„¡æ³•å¾©åŸï¼Œç¢ºå®šè¦ç¹¼çºŒå—ï¼Ÿ')) {
                return;
            }

            // Double confirmation for safety
            if (!confirm('ğŸš¨ æœ€å¾Œç¢ºèªï¼šæ‚¨å³å°‡åˆªé™¤æ•´å€‹è³‡æ–™åº«ï¼\n\nè«‹å†æ¬¡ç¢ºèªæ‚¨çœŸçš„è¦åŸ·è¡Œæ­¤æ“ä½œï¼Ÿ')) {
                return;
            }

            if (!isFirebaseReady) {
                showToast('æ­£åœ¨é€£ç·šä¸­ï¼Œè«‹ç¨å€™...', 'info');
                return;
            }

            try {
                showProgress();
                updateProgress(20, 'ğŸ—‘ï¸ æ­£åœ¨æ¸…é™¤è³‡æ–™åº«...');
                
                // Clear only the tcm-records node instead of entire database
                const recordsRef = window.firebaseDB.ref(window.firebaseDB.database, 'tcm-records');
                await window.firebaseDB.set(recordsRef, null);
                
                updateProgress(80, 'âœ… è³‡æ–™åº«å·²æ¸…é™¤');
                await new Promise(resolve => setTimeout(resolve, 500));
                updateProgress(100, 'ğŸ‰ æ¸…é™¤å®Œæˆ');
                
                // Reset local data
                herbsData = {};
                symptomsData = {};
                recordsData = {};
                
                // Clear search input
                searchInput.value = '';
                
                // Hide modal if open
                if (!searchModal.classList.contains('hidden')) {
                    hideModal();
                }
                
                showToast('ğŸ’¥ æ•´å€‹è³‡æ–™åº«å·²æ¸…é™¤', 'success');
                
                setTimeout(() => {
                    hideProgress();
                }, 1000);
                
            } catch (error) {
                console.error('Database clear error:', error);
                
                let errorMessage = 'æ¸…é™¤è³‡æ–™åº«å¤±æ•—';
                if (error.message) {
                    if (error.message.includes('permission') || error.message.includes('PERMISSION')) {
                        errorMessage = 'æ¬Šé™ä¸è¶³ï¼Œç„¡æ³•æ¸…é™¤è³‡æ–™åº«';
                    } else if (error.message.includes('network') || error.message.includes('offline')) {
                        errorMessage = 'ç¶²è·¯é€£ç·šå•é¡Œï¼Œè«‹æª¢æŸ¥ç¶²è·¯å¾Œé‡è©¦';
                    } else if (error.message.includes('Firebase')) {
                        errorMessage = 'Firebase é€£ç·šå•é¡Œï¼Œè«‹é‡æ–°æ•´ç†é é¢';
                    } else {
                        errorMessage = `æ¸…é™¤å¤±æ•—: ${error.message}`;
                    }
                }
                
                showToast(errorMessage, 'error');
                hideProgress();
            }
        }

        // Traditional-Simplified Chinese conversion maps
        const traditionalToSimplified = {
            'ç•¶': 'å½“', 'æ­¸': 'å½’', 'è£œ': 'è¡¥', 'èª¿': 'è°ƒ', 'ç¶“': 'ç»', 'æ½¤': 'æ¶¦', 'è…¸': 'è‚ ', 'é»ƒ': 'é»„', 'æ°£': 'æ°”', 'éŒ¶': 'è¡¨', 'è†¿': 'è„“', 'ç˜¡': 'ç–®', 'å¾©': 'å¤', 'è„ˆ': 'è„‰', 'è„«': 'è„±', 'é¤Š': 'å…»', 'è¡€': 'è¡€', 'ç¥›': 'ç¥›', 'é¢¨': 'é£', 'ç·©': 'ç¼“', 'é™°': 'é˜´', 'æ»‹': 'æ»‹', 'è…': 'è‚¾', 'ç²¾': 'ç²¾', 'é«“': 'é«“', 'å¯§': 'å®', 'ç¥': 'ç¥', 'æ¿•': 'æ¹¿', 'ç—°': 'ç—°', 'é¬±': 'éƒ', 'ç‡Ÿ': 'è¥', 'è¡›': 'å«', 'ç™¼': 'å‘', 'æ±—': 'æ±—', 'å®£': 'å®£', 'è‚º': 'è‚º', 'å–˜': 'å–˜', 'æ”»': 'æ”»', 'ç‡¥': 'ç‡¥', 'å¯¦': 'å®', 'ç€‰': 'æ³»', 'ç«': 'ç«', 'è—': 'è“', 'æ¶¼': 'å‡‰', 'å’½': 'å’½', 'éŠ€': 'é“¶', 'ç–': 'ç–', 'æ•£': 'æ•£', 'ç†±': 'çƒ­', 'è…«': 'è‚¿', 'çµ': 'ç»“', 'ç™°': 'ç—ˆ', 'æ·‹': 'æ·‹', 'è…¥': 'è…¥', 'è‰': 'è‰', 'æ’': 'æ’', 'è‘‰': 'å¶', 'å˜”': 'å‘•', 'è²': 'è´', 'æ¯': 'æ¯', 'ç…©': 'çƒ¦', 'ç´…': 'çº¢', 'èŠ±': 'èŠ±', 'ç˜€': 'ç˜€', 'æ¡ƒ': 'æ¡ƒ', 'ä»': 'ä»', 'è†': 'è†', 'å¼·': 'å¼º', 'ç­‹': 'ç­‹', 'éª¨': 'éª¨', 'å‚·': 'ä¼¤', 'æ²’': 'æ²¡', 'è—¥': 'è¯', 'ç«­': 'ç«­', 'æ–‚': 'æ•›', 'æ©Ÿ': 'æœº', 'é«”': 'ä½“', 'ç™‚': 'ç–—', 'è­‰': 'è¯', 'è¨º': 'è¯Š', 'æ–·': 'æ–­', 'è™•': 'å¤„', 'æ–¹': 'æ–¹', 'åŠ‘': 'å‰‚', 'æ¹¯': 'æ±¤', 'ä¸¸': 'ä¸¸', 'è†': 'è†', 'é£²': 'é¥®', 'é¡†': 'é¢—', 'ç²’': 'ç²’', 'é‡': 'é’ˆ', 'ç¸': 'ç¸', 'æ¨': 'æ¨', 'æ‹¿': 'æ‹¿', 'æŒ‰': 'æŒ‰', 'æ‘©': 'æ‘©', 'ç©´': 'ç©´', 'ä½': 'ä½', 'ç¶“': 'ç»', 'çµ¡': 'ç»œ', 'è‡Ÿ': 'è„', 'è…‘': 'è…‘', 'é™½': 'é˜³', 'è™›': 'è™š', 'å¯¦': 'å®', 'å¯’': 'å¯’', 'æº«': 'æ¸©', 'æ¶¼': 'å‡‰', 'ç‡¥': 'ç‡¥', 'æ¿•': 'æ¹¿', 'é¢¨': 'é£', 'æš‘': 'æš‘', 'ç«': 'ç«', 'ç‡¥': 'ç‡¥', 'æ¿•': 'æ¹¿', 'å¯’': 'å¯’', 'ç†±': 'çƒ­', 'è™›': 'è™š', 'å¯¦': 'å®', 'é™°': 'é˜´', 'é™½': 'é˜³', 'æ°£': 'æ°”', 'è¡€': 'è¡€', 'æ´¥': 'æ´¥', 'æ¶²': 'æ¶²', 'ç²¾': 'ç²¾', 'ç¥': 'ç¥', 'é­‚': 'é­‚', 'é­„': 'é­„', 'æ„': 'æ„', 'å¿—': 'å¿—', 'æ€': 'æ€', 'æ…®': 'è™‘', 'æ™º': 'æ™º', 'æ…§': 'æ…§'
        };

        const simplifiedToTraditional = {};
        Object.keys(traditionalToSimplified).forEach(trad => {
            const simp = traditionalToSimplified[trad];
            simplifiedToTraditional[simp] = trad;
        });

        // Convert text between Traditional and Simplified Chinese
        function convertToSimplified(text) {
            return text.split('').map(char => traditionalToSimplified[char] || char).join('');
        }

        function convertToTraditional(text) {
            return text.split('').map(char => simplifiedToTraditional[char] || char).join('');
        }

        // Enhanced similarity calculation with Traditional/Simplified support and crash protection
        function calculateSimilarity(text, query) {
            try {
                // Input validation
                if (!text || !query || typeof text !== 'string' || typeof query !== 'string') {
                    return 0;
                }
                
                // æ¸…ç†è¼¸å…¥å­—ä¸²
                text = text.trim();
                query = query.trim();
                
                if (!text || !query) {
                    return 0;
                }
                
                // Prevent infinite loops with very long strings
                if (text.length > 100 || query.length > 100) {
                    // Fallback to simple comparison for very long strings
                    if (text === query) return 1000;
                    if (text.includes(query)) return 400;
                    if (query.includes(text)) return 350;
                    return 0;
                }
                
                const textLower = text.toLowerCase();
                const queryLower = query.toLowerCase();
                
                // Convert to both Traditional and Simplified for comparison with error handling
                let textSimp, textTrad, querySimp, queryTrad;
                try {
                    textSimp = convertToSimplified(text);
                    textTrad = convertToTraditional(text);
                    querySimp = convertToSimplified(query);
                    queryTrad = convertToTraditional(query);
                } catch (conversionError) {
                    // Fallback to original strings if conversion fails
                    textSimp = text;
                    textTrad = text;
                    querySimp = query;
                    queryTrad = query;
                }
                
                // Test all combinations with safety checks
                const testCombinations = [
                    { text: textLower, query: queryLower },
                    { text: textSimp.toLowerCase(), query: queryLower },
                    { text: textTrad.toLowerCase(), query: queryLower },
                    { text: textLower, query: querySimp.toLowerCase() },
                    { text: textLower, query: queryTrad.toLowerCase() },
                    { text: textSimp.toLowerCase(), query: querySimp.toLowerCase() },
                    { text: textTrad.toLowerCase(), query: queryTrad.toLowerCase() },
                    { text: textSimp.toLowerCase(), query: queryTrad.toLowerCase() },
                    { text: textTrad.toLowerCase(), query: querySimp.toLowerCase() }
                ];
                
                let maxScore = 0;
                
                testCombinations.forEach(combo => {
                    try {
                        // Safety check for combo properties
                        if (!combo.text || !combo.query || typeof combo.text !== 'string' || typeof combo.query !== 'string') {
                            return;
                        }
                        
                        let score = 0;
                        
                        // Exact match gets highest score
                        if (combo.text === combo.query) score = 1000;
                        // Starts with query gets high score
                        else if (combo.text.startsWith(combo.query)) score = 800;
                        // Query starts with text (for short symptoms)
                        else if (combo.query.startsWith(combo.text)) score = 750;
                        // Ends with query gets medium-high score
                        else if (combo.text.endsWith(combo.query)) score = 600;
                        // Query ends with text
                        else if (combo.query.endsWith(combo.text)) score = 550;
                        // Contains query gets medium score
                        else if (combo.text.includes(combo.query)) score = 400;
                        // Query contains text (é‡è¦ï¼šé‡å°ç—‡ç‹€æœå°‹)
                        else if (combo.query.includes(combo.text)) score = 350;
                        else {
                            // Calculate character overlap score with bounds checking
                            let overlapScore = 0;
                            const maxIterations = Math.min(combo.query.length, 50); // Prevent excessive iterations
                            
                            for (let i = 0; i < maxIterations; i++) {
                                if (combo.text.includes(combo.query[i])) {
                                    overlapScore += 15; // æé«˜å­—ç¬¦åŒ¹é…åˆ†æ•¸
                                }
                            }
                            
                            // è¨ˆç®—å…±åŒå­—ç¬¦æ•¸é‡å’Œä½ç½®
                            let commonChars = 0;
                            let positionBonus = 0;
                            
                            for (let i = 0; i < combo.query.length; i++) {
                                const char = combo.query[i];
                                if (combo.text.includes(char)) {
                                    commonChars++;
                                    // å¦‚æœå­—ç¬¦åœ¨ç›¸åŒä½ç½®ï¼Œçµ¦äºˆé¡å¤–åˆ†æ•¸
                                    if (i < combo.text.length && combo.text[i] === char) {
                                        positionBonus += 20;
                                    }
                                }
                            }
                            
                            // è¨ˆç®—å­—ç¬¦è¦†è“‹ç‡
                            const coverageScore = (commonChars / Math.max(combo.query.length, combo.text.length)) * 100;
                            
                            // Length difference penalty (shorter differences get higher scores)
                            const lengthDiff = Math.abs(combo.text.length - combo.query.length);
                            const lengthScore = Math.max(0, 50 - lengthDiff * 2); // é™ä½é•·åº¦æ‡²ç½°
                            
                            // ç¶œåˆè©•åˆ†
                            score = overlapScore + lengthScore + (commonChars * 8) + positionBonus + coverageScore;
                        }
                        
                        maxScore = Math.max(maxScore, score);
                    } catch (comboError) {
                        console.warn('Combo calculation error:', comboError);
                    }
                });
                
                return maxScore;
            } catch (error) {
                console.warn('Similarity calculation error:', error);
                return 0; // Return 0 instead of crashing
            }
        }

        // å…¨æ–°çš„æœå°‹å‡½æ•¸ - å°ˆé–€è§£æ±ºç—‡ç‹€æœå°‹å•é¡Œ
        function searchFunction() {
            try {
                const query = searchInput.value ? searchInput.value.trim() : '';
                if (!query) {
                    showToast('è«‹è¼¸å…¥æœå°‹é—œéµå­—', 'error');
                    return;
                }

                // Show loading state
                if (searchBtn) {
                    searchBtn.disabled = true;
                    searchBtn.innerHTML = 'ğŸ” æœå°‹ä¸­...';
                }

                setTimeout(() => {
                    let results = [];
                    
                    try {
                        console.log('=== é–‹å§‹æœå°‹ ===');
                        console.log('æœå°‹é—œéµå­—:', query);
                        console.log('ä¸­è—¥è³‡æ–™æ•¸é‡:', Object.keys(herbsData).length);
                        console.log('ç—‡ç‹€è³‡æ–™æ•¸é‡:', Object.keys(symptomsData).length);
                        console.log('è¨˜éŒ„è³‡æ–™æ•¸é‡:', Object.keys(recordsData).length);
                        
                        // æª¢æŸ¥è³‡æ–™çµæ§‹
                        console.log('ç—‡ç‹€è³‡æ–™çµæ§‹æª¢æŸ¥:');
                        const symptomKeys = Object.keys(symptomsData);
                        console.log('å‰10å€‹ç—‡ç‹€:', symptomKeys.slice(0, 10));
                        
                        // æª¢æŸ¥æ˜¯å¦æœ‰åŒ…å«æŸ¥è©¢å­—ä¸²çš„ç—‡ç‹€
                        const containingSymptoms = symptomKeys.filter(symptom => 
                            symptom && symptom.includes && symptom.includes(query)
                        );
                        console.log('åŒ…å«æŸ¥è©¢å­—ä¸²çš„ç—‡ç‹€:', containingSymptoms);
                        
                        // æª¢æŸ¥æ˜¯å¦æœ‰è¢«æŸ¥è©¢å­—ä¸²åŒ…å«çš„ç—‡ç‹€
                        const containedSymptoms = symptomKeys.filter(symptom => 
                            symptom && query.includes && query.includes(symptom)
                        );
                        console.log('è¢«æŸ¥è©¢å­—ä¸²åŒ…å«çš„ç—‡ç‹€:', containedSymptoms);
                        
                        // å…¨é¢æœå°‹ - ä¸åˆ†å„ªå…ˆç´šï¼Œç›´æ¥æ‰¾æ‰€æœ‰åŒ¹é…
                        const allMatches = [];
                        
                        // 1. æœå°‹ä¸­è—¥
                        console.log('--- æœå°‹ä¸­è—¥ ---');
                        Object.keys(herbsData).forEach(herb => {
                            if (!herb || !herbsData[herb]) return;
                            
                            let matchScore = 0;
                            let matchType = '';
                            
                            // å®Œå…¨åŒ¹é…
                            if (herb === query) {
                                matchScore = 1000;
                                matchType = 'exact';
                            }
                            // åŒ…å«åŒ¹é…
                            else if (herb.includes(query)) {
                                matchScore = 800;
                                matchType = 'partial';
                            }
                            // è¢«åŒ…å«åŒ¹é…
                            else if (query.includes(herb)) {
                                matchScore = 750;
                                matchType = 'partial';
                            }
                            // æ¨¡ç³ŠåŒ¹é…
                            else {
                                const similarity = calculateSimilarity(herb, query);
                                if (similarity >= 100) {
                                    matchScore = similarity;
                                    matchType = 'fuzzy';
                                }
                            }
                            
                            if (matchScore > 0) {
                                console.log('æ‰¾åˆ°ä¸­è—¥åŒ¹é…:', herb, 'åˆ†æ•¸:', matchScore);
                                allMatches.push({
                                    type: 'ä¸­è—¥',
                                    name: herb,
                                    items: herbsData[herb].slice(0, 50),
                                    label: 'å°æ‡‰ç—‡ç‹€',
                                    similarity: matchScore,
                                    matchType: matchType
                                });
                            }
                        });
                        
                        // 2. æœå°‹ç—‡ç‹€ - ä½¿ç”¨æ›´å¯¬é¬†çš„åŒ¹é…ç­–ç•¥
                        console.log('--- æœå°‹ç—‡ç‹€ ---');
                        Object.keys(symptomsData).forEach(symptom => {
                            if (!symptom || !symptomsData[symptom]) return;
                            
                            let matchScore = 0;
                            let matchType = '';
                            
                            // å®Œå…¨åŒ¹é…
                            if (symptom === query) {
                                matchScore = 1000;
                                matchType = 'exact';
                                console.log('å®Œå…¨åŒ¹é…ç—‡ç‹€:', symptom);
                            }
                            // ç—‡ç‹€åŒ…å«æŸ¥è©¢
                            else if (symptom.includes(query)) {
                                matchScore = 800;
                                matchType = 'partial';
                                console.log('ç—‡ç‹€åŒ…å«æŸ¥è©¢:', symptom, 'åŒ…å«', query);
                            }
                            // æŸ¥è©¢åŒ…å«ç—‡ç‹€
                            else if (query.includes(symptom)) {
                                matchScore = 750;
                                matchType = 'partial';
                                console.log('æŸ¥è©¢åŒ…å«ç—‡ç‹€:', query, 'åŒ…å«', symptom);
                            }
                            // å–®å­—åŒ¹é… - æ–°å¢é‚è¼¯
                            else {
                                let hasCharMatch = false;
                                
                                // æª¢æŸ¥æ¯å€‹æŸ¥è©¢å­—ç¬¦æ˜¯å¦åœ¨ç—‡ç‹€ä¸­
                                for (let char of query) {
                                    if (symptom.includes(char)) {
                                        hasCharMatch = true;
                                        break;
                                    }
                                }
                                
                                // æª¢æŸ¥æ¯å€‹ç—‡ç‹€å­—ç¬¦æ˜¯å¦åœ¨æŸ¥è©¢ä¸­
                                if (!hasCharMatch) {
                                    for (let char of symptom) {
                                        if (query.includes(char)) {
                                            hasCharMatch = true;
                                            break;
                                        }
                                    }
                                }
                                
                                if (hasCharMatch) {
                                    // è¨ˆç®—å­—ç¬¦é‡ç–Šåº¦
                                    let overlapCount = 0;
                                    for (let char of query) {
                                        if (symptom.includes(char)) {
                                            overlapCount++;
                                        }
                                    }
                                    
                                    const overlapRatio = overlapCount / query.length;
                                    if (overlapRatio >= 0.3) { // 30%é‡ç–Šå³èªç‚ºåŒ¹é…
                                        matchScore = 300 + (overlapRatio * 200);
                                        matchType = 'fuzzy';
                                        console.log('å­—ç¬¦é‡ç–ŠåŒ¹é…:', symptom, 'é‡ç–Šç‡:', overlapRatio);
                                    }
                                }
                                
                                // å¦‚æœé‚„æ˜¯æ²’åŒ¹é…ï¼Œå˜—è©¦ç›¸ä¼¼åº¦è¨ˆç®—
                                if (matchScore === 0) {
                                    const similarity = calculateSimilarity(symptom, query);
                                    if (similarity >= 50) { // é™ä½é–€æª»
                                        matchScore = similarity;
                                        matchType = 'fuzzy';
                                        console.log('ç›¸ä¼¼åº¦åŒ¹é…:', symptom, 'ç›¸ä¼¼åº¦:', similarity);
                                    }
                                }
                            }
                            
                            if (matchScore > 0) {
                                allMatches.push({
                                    type: 'ç—‡ç‹€',
                                    name: symptom,
                                    items: symptomsData[symptom].slice(0, 50),
                                    label: 'å°æ‡‰ä¸­è—¥',
                                    similarity: matchScore,
                                    matchType: matchType
                                });
                            }
                        });
                        
                        // 3. å¦‚æœç—‡ç‹€æœå°‹çµæœå¤ªå°‘ï¼Œå˜—è©¦å¾è¨˜éŒ„ä¸­ç›´æ¥æœå°‹
                        const symptomMatches = allMatches.filter(m => m.type === 'ç—‡ç‹€');
                        console.log('ç—‡ç‹€åŒ¹é…æ•¸é‡:', symptomMatches.length);
                        
                        if (symptomMatches.length < 3) {
                            console.log('--- å¾è¨˜éŒ„ä¸­æœå°‹ç—‡ç‹€ ---');
                            const foundSymptoms = new Set();
                            
                            Object.values(recordsData).forEach(record => {
                                if (!record || !record.symptom) return;
                                
                                const symptom = record.symptom;
                                if (foundSymptoms.has(symptom)) return;
                                
                                // æ›´å¯¬é¬†çš„åŒ¹é…
                                let shouldMatch = false;
                                
                                if (symptom.includes(query) || query.includes(symptom)) {
                                    shouldMatch = true;
                                } else {
                                    // æª¢æŸ¥å–®å­—åŒ¹é…
                                    for (let char of query) {
                                        if (symptom.includes(char)) {
                                            shouldMatch = true;
                                            break;
                                        }
                                    }
                                }
                                
                                if (shouldMatch) {
                                    foundSymptoms.add(symptom);
                                    console.log('å¾è¨˜éŒ„ä¸­æ‰¾åˆ°ç—‡ç‹€:', symptom);
                                    
                                    // æ‰¾åˆ°å°æ‡‰çš„ä¸­è—¥
                                    const relatedHerbs = Object.values(recordsData)
                                        .filter(r => r.symptom === symptom)
                                        .map(r => r.herb)
                                        .filter((herb, index, arr) => arr.indexOf(herb) === index);
                                    
                                    if (relatedHerbs.length > 0) {
                                        allMatches.push({
                                            type: 'ç—‡ç‹€',
                                            name: symptom,
                                            items: relatedHerbs.slice(0, 50),
                                            label: 'å°æ‡‰ä¸­è—¥',
                                            similarity: 600,
                                            matchType: 'partial'
                                        });
                                    }
                                }
                            });
                        }
                        
                        // æ’åºçµæœ - å„ªå…ˆç´šï¼šåŒ¹é…é¡å‹ > ç›¸ä¼¼åº¦ > é¡å‹
                        results = allMatches.sort((a, b) => {
                            // 1. é¦–å…ˆæŒ‰åŒ¹é…é¡å‹æ’åºï¼ˆå®Œå…¨åŒ¹é… > éƒ¨åˆ†åŒ¹é… > æ¨¡ç³ŠåŒ¹é…ï¼‰
                            const matchTypeOrder = { 'exact': 3, 'partial': 2, 'fuzzy': 1 };
                            const aMatchOrder = matchTypeOrder[a.matchType] || 0;
                            const bMatchOrder = matchTypeOrder[b.matchType] || 0;
                            
                            if (aMatchOrder !== bMatchOrder) {
                                return bMatchOrder - aMatchOrder; // é«˜åˆ†åœ¨å‰
                            }
                            
                            // 2. ç›¸åŒåŒ¹é…é¡å‹æ™‚ï¼ŒæŒ‰ç›¸ä¼¼åº¦æ’åº
                            const aSimilarity = a.similarity || 0;
                            const bSimilarity = b.similarity || 0;
                            
                            if (aSimilarity !== bSimilarity) {
                                return bSimilarity - aSimilarity; // é«˜åˆ†åœ¨å‰
                            }
                            
                            // 3. ç›¸ä¼¼åº¦ç›¸åŒæ™‚ï¼Œä¸­è—¥å„ªå…ˆ
                            if (a.type !== b.type) {
                                return a.type === 'ä¸­è—¥' ? -1 : 1;
                            }
                            
                            // 4. æœ€å¾ŒæŒ‰åç¨±é•·åº¦æ’åºï¼ˆçŸ­çš„åœ¨å‰ï¼Œé€šå¸¸æ›´ç²¾ç¢ºï¼‰
                            return a.name.length - b.name.length;
                        });
                        
                        // é™åˆ¶çµæœæ•¸é‡
                        results = results.slice(0, 100);
                        
                        console.log('=== æœå°‹å®Œæˆ ===');
                        console.log('ç¸½çµæœæ•¸é‡:', results.length);
                        console.log('ä¸­è—¥çµæœ:', results.filter(r => r.type === 'ä¸­è—¥').length);
                        console.log('ç—‡ç‹€çµæœ:', results.filter(r => r.type === 'ç—‡ç‹€').length);
                        
                    } catch (searchError) {
                        console.error('æœå°‹è™•ç†éŒ¯èª¤:', searchError);
                        results = [];
                    }

                    // é¡¯ç¤ºçµæœ
                    try {
                        displayResults(results, query);
                    } catch (displayError) {
                        console.error('é¡¯ç¤ºçµæœéŒ¯èª¤:', displayError);
                        showToast('æœå°‹çµæœé¡¯ç¤ºå¤±æ•—', 'error');
                    }

                    // æ¢å¾©æŒ‰éˆ•ç‹€æ…‹
                    try {
                        if (searchBtn) {
                            searchBtn.disabled = false;
                            searchBtn.innerHTML = 'ğŸ” æœå°‹';
                        }
                    } catch (buttonError) {
                        console.error('æŒ‰éˆ•æ¢å¾©éŒ¯èª¤:', buttonError);
                    }

                }, 100);

            } catch (outerError) {
                console.error('æœå°‹å‡½æ•¸å¤–å±¤éŒ¯èª¤:', outerError);
                
                try {
                    if (searchBtn) {
                        searchBtn.disabled = false;
                        searchBtn.innerHTML = 'ğŸ” æœå°‹';
                    }
                    showToast('æœå°‹åŠŸèƒ½æš«æ™‚ç„¡æ³•ä½¿ç”¨', 'error');
                } catch (emergencyError) {
                    console.error('ç·Šæ€¥æ¢å¾©å¤±æ•—:', emergencyError);
                }
            }
        }

        // Modal control functions
        function showModal() {
            searchModal.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
            
            // Scroll modal content to top
            const modalContent = searchModal.querySelector('.overflow-y-auto');
            if (modalContent) {
                modalContent.scrollTop = 0;
            }
        }

        function hideModal() {
            searchModal.classList.add('hidden');
            document.body.style.overflow = 'auto';
        }

        // Display search results in modal
        function displayResults(results, query) {
            // Update modal header
            modalSearchQuery.textContent = `æœå°‹é—œéµå­—ï¼šã€Œ${query}ã€`;
            modalResultCount.textContent = `æ‰¾åˆ° ${results.length} å€‹çµæœ`;

            if (results.length === 0) {
                modalResultsContainer.innerHTML = `
                    <div class="text-center py-12">
                        <div class="text-gray-400 text-4xl mb-4">ğŸ”</div>
                        <h4 class="text-lg font-medium text-gray-900 mb-2">æœªæ‰¾åˆ°ç›¸é—œè³‡æ–™</h4>
                        <p class="text-gray-500">æœªæ‰¾åˆ°èˆ‡ã€Œ${query}ã€ç›¸é—œçš„ä¸­è—¥æˆ–ç—‡ç‹€è³‡æ–™</p>
                        <div class="mt-6">
                            <button onclick="hideModal(); searchInput.focus();" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                                é‡æ–°æœå°‹
                            </button>
                        </div>
                    </div>
                `;
            } else {
                modalResultsContainer.innerHTML = results.map((result, index) => {
                    // Determine match quality indicator
                    let matchIndicator = '';
                    let matchColor = '';
                    if (result.matchType === 'exact') {
                        matchIndicator = 'ğŸ¯ å®Œå…¨åŒ¹é…';
                        matchColor = 'text-green-600';
                    } else if (result.matchType === 'partial') {
                        matchIndicator = 'ğŸ” éƒ¨åˆ†åŒ¹é…';
                        matchColor = 'text-blue-600';
                    } else {
                        matchIndicator = 'ğŸ’¡ ç›¸é—œåŒ¹é…';
                        matchColor = 'text-purple-600';
                    }

                    return `
                        <div class="border border-gray-200 rounded-lg p-5 mb-4 border-l-4 ${result.type === 'ä¸­è—¥' ? 'border-l-blue-500' : 'border-l-green-500'} fade-in hover:shadow-md transition-shadow">
                            <div class="flex items-center justify-between mb-4">
                                <div class="flex items-center">
                                    <span class="inline-block px-3 py-1 text-sm font-medium rounded ${result.type === 'ä¸­è—¥' ? 'bg-blue-100 text-blue-800' : 'bg-green-100 text-green-800'}">${result.type}</span>
                                    <h4 class="font-semibold text-gray-900 ml-3 text-lg">${result.name}</h4>
                                    ${index < 3 ? '<span class="ml-2 text-xs bg-yellow-100 text-yellow-800 px-2 py-1 rounded">æ¨è–¦</span>' : ''}
                                </div>
                                <div class="text-sm ${matchColor} font-medium">${matchIndicator}</div>
                            </div>
                            <p class="text-sm text-gray-600 mb-4 font-medium">${result.label}ï¼š</p>
                            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2">
                                ${result.items.map(item => `
                                    <span class="inline-block px-4 py-2 bg-gray-50 text-gray-700 rounded-lg text-sm hover:bg-blue-50 hover:text-blue-700 cursor-pointer transition-colors border border-gray-200 hover:border-blue-300" onclick="hideModal(); searchInput.value='${item}'; searchFunction();">${item}</span>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }).join('');
            }

            // Show modal
            showModal();
        }

        // Edit mode functions
        function showEditModal() {
            // Show loading state
            editModeBtn.disabled = true;
            editModeBtn.innerHTML = 'â³ è¼‰å…¥ä¸­...';
            
            // Show modal first with loading state
            editModal.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
            
            // Show loading in modal content
            editItemsList.innerHTML = `
                <div class="text-center py-12">
                    <div class="loading-spinner mx-auto mb-4"></div>
                    <p class="text-gray-600">æ­£åœ¨è¼‰å…¥ç·¨è¼¯è³‡æ–™...</p>
                </div>
            `;
            editItemCount.textContent = 'è¼‰å…¥ä¸­...';
            
            // Prepare data with delay to show loading
            setTimeout(() => {
                prepareEditData();
                
                // Reset button state
                editModeBtn.disabled = false;
                editModeBtn.innerHTML = 'âœï¸ ç·¨è¼¯æ¨¡å¼';
                
                // Focus on search input
                setTimeout(() => {
                    editSearchInput.focus();
                }, 100);
            }, 500);
        }

        function hideEditModal() {
            editModal.classList.add('hidden');
            document.body.style.overflow = 'auto';
            
            // Reset search
            editSearchInput.value = '';
            editTypeFilter.value = 'all';
        }

        function showEditDetailModal() {
            editDetailModal.classList.remove('hidden');
        }

        function hideEditDetailModal() {
            editDetailModal.classList.add('hidden');
            currentEditItem = null;
            currentEditType = null;
            
            // Clear form
            editItemName.value = '';
            editRelatedItems.innerHTML = '';
            newRelatedItem.value = '';
        }

        function prepareEditData() {
            editItemsData = [];
            
            // Add herbs
            Object.keys(herbsData).forEach(herb => {
                editItemsData.push({
                    type: 'herb',
                    name: herb,
                    relatedItems: herbsData[herb] || [],
                    count: (herbsData[herb] || []).length
                });
            });
            
            // Add symptoms
            Object.keys(symptomsData).forEach(symptom => {
                editItemsData.push({
                    type: 'symptom',
                    name: symptom,
                    relatedItems: symptomsData[symptom] || [],
                    count: (symptomsData[symptom] || []).length
                });
            });
            
            // Sort by name
            editItemsData.sort((a, b) => a.name.localeCompare(b.name));
            
            displayEditItems();
        }

        function displayEditItems() {
            const searchTerm = editSearchInput.value.toLowerCase();
            const typeFilter = editTypeFilter.value;
            
            let filteredItems = editItemsData.filter(item => {
                const matchesSearch = !searchTerm || item.name.toLowerCase().includes(searchTerm);
                const matchesType = typeFilter === 'all' || item.type === typeFilter;
                return matchesSearch && matchesType;
            });
            
            editItemCount.textContent = `é¡¯ç¤º ${filteredItems.length} å€‹é …ç›®`;
            
            if (filteredItems.length === 0) {
                editItemsList.innerHTML = `
                    <div class="text-center py-12">
                        <div class="text-gray-400 text-4xl mb-4">ğŸ“</div>
                        <h4 class="text-lg font-medium text-gray-900 mb-2">æ²’æœ‰æ‰¾åˆ°é …ç›®</h4>
                        <p class="text-gray-500">è«‹èª¿æ•´æœå°‹æ¢ä»¶æˆ–ç¯©é¸å™¨</p>
                    </div>
                `;
                return;
            }
            
            editItemsList.innerHTML = filteredItems.map(item => `
                <div class="border border-gray-200 rounded-lg p-4 hover:shadow-md transition-shadow cursor-pointer" onclick="openEditDetail('${item.name}', '${item.type}')">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center space-x-3">
                            <span class="inline-block px-3 py-1 text-sm font-medium rounded ${item.type === 'herb' ? 'bg-blue-100 text-blue-800' : 'bg-green-100 text-green-800'}">
                                ${item.type === 'herb' ? 'ä¸­è—¥' : 'ç—‡ç‹€'}
                            </span>
                            <span class="font-medium text-gray-900">${item.name}</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <span class="text-sm text-gray-500">${item.count} å€‹é—œè¯</span>
                            <svg class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                            </svg>
                        </div>
                    </div>
                    <div class="mt-2 text-sm text-gray-600">
                        ${item.relatedItems.slice(0, 3).join('ã€')}${item.relatedItems.length > 3 ? '...' : ''}
                    </div>
                </div>
            `).join('');
        }

        function openEditDetail(itemName, itemType) {
            currentEditItem = itemName;
            currentEditType = itemType;
            
            // Set up modal appearance
            if (itemType === 'herb') {
                editDetailIcon.className = 'w-8 h-8 bg-blue-600 rounded-lg flex items-center justify-center';
                editDetailIcon.innerHTML = '<span class="text-white font-bold">è—¥</span>';
                editDetailTitle.textContent = `ç·¨è¼¯ä¸­è—¥ï¼š${itemName}`;
                editDetailSubtitle.textContent = 'ä¿®æ”¹ä¸­è—¥åç¨±å’Œå°æ‡‰ç—‡ç‹€';
                editRelatedLabel.textContent = 'å°æ‡‰ç—‡ç‹€';
            } else {
                editDetailIcon.className = 'w-8 h-8 bg-green-600 rounded-lg flex items-center justify-center';
                editDetailIcon.innerHTML = '<span class="text-white font-bold">ç—‡</span>';
                editDetailTitle.textContent = `ç·¨è¼¯ç—‡ç‹€ï¼š${itemName}`;
                editDetailSubtitle.textContent = 'ä¿®æ”¹ç—‡ç‹€åç¨±å’Œå°æ‡‰ä¸­è—¥';
                editRelatedLabel.textContent = 'å°æ‡‰ä¸­è—¥';
            }
            
            // Fill form
            editItemName.value = itemName;
            
            const relatedItems = itemType === 'herb' ? (herbsData[itemName] || []) : (symptomsData[itemName] || []);
            displayRelatedItems(relatedItems);
            
            showEditDetailModal();
        }

        function displayRelatedItems(items) {
            editRelatedItems.innerHTML = items.map((item, index) => `
                <div class="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                    <span class="text-gray-900">${item}</span>
                    <button onclick="removeRelatedItem(${index})" class="text-red-600 hover:text-red-800 transition-colors">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
            `).join('');
        }

        function removeRelatedItem(index) {
            const relatedItems = currentEditType === 'herb' ? (herbsData[currentEditItem] || []) : (symptomsData[currentEditItem] || []);
            relatedItems.splice(index, 1);
            displayRelatedItems(relatedItems);
        }

        function addNewRelatedItem() {
            const newItem = newRelatedItem.value.trim();
            if (!newItem) {
                showToast('è«‹è¼¸å…¥é—œè¯é …ç›®åç¨±', 'error');
                return;
            }
            
            const relatedItems = currentEditType === 'herb' ? (herbsData[currentEditItem] || []) : (symptomsData[currentEditItem] || []);
            
            if (relatedItems.includes(newItem)) {
                showToast('è©²é …ç›®å·²å­˜åœ¨', 'error');
                return;
            }
            
            relatedItems.push(newItem);
            displayRelatedItems(relatedItems);
            newRelatedItem.value = '';
            
            showToast('å·²æ–°å¢é—œè¯é …ç›®', 'success');
        }

        async function saveEditChanges() {
            const newName = editItemName.value.trim();
            const oldName = currentEditItem;
            
            if (!newName) {
                showToast('è«‹è¼¸å…¥é …ç›®åç¨±', 'error');
                return;
            }
            
            if (!isFirebaseReady) {
                showToast('è³‡æ–™åº«æœªé€£ç·šï¼Œç„¡æ³•å„²å­˜', 'error');
                return;
            }
            
            try {
                saveEditBtn.disabled = true;
                saveEditBtn.innerHTML = 'ğŸ’¾ å„²å­˜ä¸­...';
                
                const relatedItems = currentEditType === 'herb' ? (herbsData[currentEditItem] || []) : (symptomsData[currentEditItem] || []);
                
                // If name changed, need to update all related records
                if (newName !== oldName) {
                    // Find all records that need to be updated
                    const recordsToUpdate = [];
                    const recordsToDelete = [];
                    
                    Object.entries(recordsData).forEach(([key, record]) => {
                        if (currentEditType === 'herb' && record.herb === oldName) {
                            recordsToDelete.push(key);
                            recordsToUpdate.push({
                                key: `${newName}_${record.symptom}`.replace(/[.#$[\]]/g, '_'),
                                herb: newName,
                                symptom: record.symptom,
                                timestamp: Date.now()
                            });
                        } else if (currentEditType === 'symptom' && record.symptom === oldName) {
                            recordsToDelete.push(key);
                            recordsToUpdate.push({
                                key: `${record.herb}_${newName}`.replace(/[.#$[\]]/g, '_'),
                                herb: record.herb,
                                symptom: newName,
                                timestamp: Date.now()
                            });
                        }
                    });
                    
                    // Delete old records
                    for (const key of recordsToDelete) {
                        const recordRef = window.firebaseDB.ref(window.firebaseDB.database, `tcm-records/${key}`);
                        await window.firebaseDB.remove(recordRef);
                    }
                    
                    // Add updated records
                    for (const record of recordsToUpdate) {
                        const recordRef = window.firebaseDB.ref(window.firebaseDB.database, `tcm-records/${record.key}`);
                        await window.firebaseDB.set(recordRef, {
                            herb: record.herb,
                            symptom: record.symptom,
                            timestamp: record.timestamp
                        });
                    }
                }
                
                // Update related items
                const currentRelatedItems = currentEditType === 'herb' ? (herbsData[oldName] || []) : (symptomsData[oldName] || []);
                const newRelatedItems = relatedItems;
                
                // Find items to add and remove
                const itemsToAdd = newRelatedItems.filter(item => !currentRelatedItems.includes(item));
                const itemsToRemove = currentRelatedItems.filter(item => !newRelatedItems.includes(item));
                
                // Remove old relationships
                for (const item of itemsToRemove) {
                    const key = currentEditType === 'herb' 
                        ? `${newName}_${item}`.replace(/[.#$[\]]/g, '_')
                        : `${item}_${newName}`.replace(/[.#$[\]]/g, '_');
                    
                    const recordRef = window.firebaseDB.ref(window.firebaseDB.database, `tcm-records/${key}`);
                    await window.firebaseDB.remove(recordRef);
                }
                
                // Add new relationships
                for (const item of itemsToAdd) {
                    const key = currentEditType === 'herb' 
                        ? `${newName}_${item}`.replace(/[.#$[\]]/g, '_')
                        : `${item}_${newName}`.replace(/[.#$[\]]/g, '_');
                    
                    const recordRef = window.firebaseDB.ref(window.firebaseDB.database, `tcm-records/${key}`);
                    await window.firebaseDB.set(recordRef, {
                        herb: currentEditType === 'herb' ? newName : item,
                        symptom: currentEditType === 'herb' ? item : newName,
                        timestamp: Date.now()
                    });
                }
                
                showToast('âœ… è®Šæ›´å·²å„²å­˜', 'success');
                hideEditDetailModal();
                prepareEditData(); // Refresh edit data
                
            } catch (error) {
                console.error('Save edit error:', error);
                showToast('å„²å­˜å¤±æ•—ï¼š' + error.message, 'error');
            } finally {
                saveEditBtn.disabled = false;
                saveEditBtn.innerHTML = 'ğŸ’¾ å„²å­˜è®Šæ›´';
            }
        }

        async function deleteCurrentItem() {
            if (!confirm(`ç¢ºå®šè¦åˆªé™¤ã€Œ${currentEditItem}ã€å—ï¼Ÿ\n\né€™å°‡åˆªé™¤æ‰€æœ‰ç›¸é—œçš„è¨˜éŒ„ï¼Œæ­¤æ“ä½œç„¡æ³•å¾©åŸã€‚`)) {
                return;
            }
            
            if (!isFirebaseReady) {
                showToast('è³‡æ–™åº«æœªé€£ç·šï¼Œç„¡æ³•åˆªé™¤', 'error');
                return;
            }
            
            try {
                deleteItemBtn.disabled = true;
                deleteItemBtn.innerHTML = 'ğŸ—‘ï¸ åˆªé™¤ä¸­...';
                
                // Find all records to delete
                const recordsToDelete = [];
                
                Object.entries(recordsData).forEach(([key, record]) => {
                    if ((currentEditType === 'herb' && record.herb === currentEditItem) ||
                        (currentEditType === 'symptom' && record.symptom === currentEditItem)) {
                        recordsToDelete.push(key);
                    }
                });
                
                // Delete all related records
                for (const key of recordsToDelete) {
                    const recordRef = window.firebaseDB.ref(window.firebaseDB.database, `tcm-records/${key}`);
                    await window.firebaseDB.remove(recordRef);
                }
                
                showToast(`ğŸ—‘ï¸ å·²åˆªé™¤ã€Œ${currentEditItem}ã€åŠå…¶ ${recordsToDelete.length} å€‹ç›¸é—œè¨˜éŒ„`, 'success');
                hideEditDetailModal();
                prepareEditData(); // Refresh edit data
                
            } catch (error) {
                console.error('Delete item error:', error);
                showToast('åˆªé™¤å¤±æ•—ï¼š' + error.message, 'error');
            } finally {
                deleteItemBtn.disabled = false;
                deleteItemBtn.innerHTML = 'ğŸ—‘ï¸ åˆªé™¤é …ç›®';
            }
        }

        // Update display
        function updateDisplay() {
            // Update counts
            herbCount.textContent = Object.keys(herbsData).length;
            symptomCount.textContent = Object.keys(symptomsData).length;
            recordCount.textContent = Object.keys(recordsData).length;

            // Update herbs list
            if (Object.keys(herbsData).length === 0) {
                herbsList.innerHTML = '<p class="text-gray-500 text-center py-8">æš«ç„¡è³‡æ–™</p>';
            } else {
                herbsList.innerHTML = Object.keys(herbsData).sort().map(herb => `
                    <div class="flex items-center justify-between p-3 bg-gray-50 rounded-lg hover:bg-gray-100 cursor-pointer transition-colors" onclick="searchInput.value='${herb}'; searchFunction();">
                        <span class="font-medium text-gray-900">${herb}</span>
                        <span class="text-xs text-blue-600 bg-blue-100 px-2 py-1 rounded">${herbsData[herb].length}</span>
                    </div>
                `).join('');
            }

            // Update symptoms list
            if (Object.keys(symptomsData).length === 0) {
                symptomsList.innerHTML = '<p class="text-gray-500 text-center py-8">æš«ç„¡è³‡æ–™</p>';
            } else {
                symptomsList.innerHTML = Object.keys(symptomsData).sort().map(symptom => `
                    <div class="flex items-center justify-between p-3 bg-gray-50 rounded-lg hover:bg-gray-100 cursor-pointer transition-colors" onclick="searchInput.value='${symptom}'; searchFunction();">
                        <span class="font-medium text-gray-900">${symptom}</span>
                        <span class="text-xs text-green-600 bg-green-100 px-2 py-1 rounded">${symptomsData[symptom].length}</span>
                    </div>
                `).join('');
            }
        }



        // Event listeners
        searchBtn.addEventListener('click', searchFunction);
        clearBtn.addEventListener('click', () => {
            searchInput.value = '';
        });
        importBtn.addEventListener('click', importDataFunction);
        clearAllBtn.addEventListener('click', clearAllData);
        clearDatabaseBtn.addEventListener('click', clearDatabase);
        editModeBtn.addEventListener('click', showEditModal);
        exportDataBtn.addEventListener('click', exportDataToTxt);
        
        // Modal event listeners
        closeModal.addEventListener('click', hideModal);
        newSearchBtn.addEventListener('click', () => {
            hideModal();
            searchInput.focus();
        });
        
        // Close modal when clicking outside
        searchModal.addEventListener('click', (e) => {
            if (e.target === searchModal) {
                hideModal();
            }
        });
        
        // Edit modal event listeners
        closeEditModal.addEventListener('click', hideEditModal);
        closeEditModalBtn.addEventListener('click', hideEditModal);
        editSearchInput.addEventListener('input', displayEditItems);
        editTypeFilter.addEventListener('change', displayEditItems);
        
        // Edit detail modal event listeners
        closeEditDetailModal.addEventListener('click', hideEditDetailModal);
        cancelEditBtn.addEventListener('click', hideEditDetailModal);
        saveEditBtn.addEventListener('click', saveEditChanges);
        deleteItemBtn.addEventListener('click', deleteCurrentItem);
        addRelatedItemBtn.addEventListener('click', addNewRelatedItem);
        
        // Close modals when clicking outside
        editModal.addEventListener('click', (e) => {
            if (e.target === editModal) {
                hideEditModal();
            }
        });
        
        editDetailModal.addEventListener('click', (e) => {
            if (e.target === editDetailModal) {
                hideEditDetailModal();
            }
        });
        
        // Enter key support for new related item
        newRelatedItem.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                addNewRelatedItem();
            }
        });
        
        // Close modal with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (!editDetailModal.classList.contains('hidden')) {
                    hideEditDetailModal();
                } else if (!editModal.classList.contains('hidden')) {
                    hideEditModal();
                } else if (!searchModal.classList.contains('hidden')) {
                    hideModal();
                }
            }
        });
        


        // Auto-detect format on input change
        importData.addEventListener('input', () => {
            if (importData.value.trim()) {
                const detectedFormat = detectFormat(importData.value);
                const formatNames = {
                    colon: 'å†’è™Ÿæ ¼å¼',
                    comma: 'é€—è™Ÿæ ¼å¼',
                    arrow: 'ç®­é ­æ ¼å¼',
                    bracket: 'æ–¹æ‹¬è™Ÿæ ¼å¼',
                    json: 'JSONæ ¼å¼'
                };
                
                formatHint.textContent = `è‡ªå‹•è­˜åˆ¥ï¼š${formatNames[detectedFormat] || 'æœªçŸ¥æ ¼å¼'}`;
            } else {
                formatHint.textContent = '';
            }
        });

        // Enter key support
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                searchFunction();
            }
        });



        // Initialize the application
        initializeFirebase();
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9668f058b3605de0',t:'MTc1Mzc1MzU0OC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
